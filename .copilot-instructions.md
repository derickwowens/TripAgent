# TripAgent - Copilot Instructions

> This document describes the architecture, rules, and context management for TripAgent, a National Park trip planning AI assistant.

## Overview

TripAgent is a React Native mobile app with an Express.js backend that uses Claude AI to help users plan National Park trips. The app integrates multiple APIs (NPS, Yelp, Google Maps, Unsplash, Amadeus) through a unified tool system.

---

## Authoritative Data Sources

### National Park Service (NPS) API
- **Source**: `https://developer.nps.gov/api/v1/parks`
- **Usage**: All park names, codes, and state mappings come from NPS API
- **Files using NPS data**:
  - `src/utils/parkCodeLookup.ts` - Park code lookup and validation
  - `src/api/chat/parkFeatures.ts` - Park-specific photo features
  - `src/api/chat/systemPrompt.ts` - System prompt park references
  - `src/api/chat/toolDefinitions.ts` - Tool descriptions with park codes
  - `mobile/src/components/home/OnboardingFlow.tsx` - Random park selection

### Park Code Format
- 4-letter lowercase codes (e.g., `yose`, `yell`, `grca`, `zion`)
- Always use official NPS codes for API calls
- Full list: `acad, arch, badl, bibe, bisc, blca, brca, cany, care, cave, chis, cong, crla, cuva, deva, dena, drto, ever, gaar, jeff, glac, glba, grca, grte, grba, grsa, grsm, gumo, hale, havo, hosp, indu, isro, jotr, katm, kefj, kova, lacl, lavo, maca, meve, mora, neri, noca, olym, pefo, pinn, redw, romo, sagu, seki, shen, thro, viis, voya, whsa, wica, wrst, yell, yose, zion`

---

## Context Management System

### Context Priority (highest to lowest)
1. **Leg-specific override** - Override for a specific trip segment
2. **Conversation override** - User changed something in current chat
3. **Trip context** - Current trip being planned
4. **Profile defaults** - User's saved preferences
5. **System defaults** - Fallback values

### ChatContext Structure
```typescript
interface ChatContext {
  userLocation?: {
    city: string;
    state: string;
    nearestAirport: string;  // Auto-detected, used as flight origin default
  };
  tripContext?: {
    destination?: string;
    parkCode?: string;
    numDays?: number;
    numTravelers?: number;
    overrides?: Record<string, any>;  // Dynamic overrides from chat
    legs?: TripLeg[];                  // Multi-segment trips
    activeLeg?: number;                // Currently discussed leg
  };
  userProfile?: string;    // Raw profile text
  defaults?: ContextDefaults;  // Parsed preferences
}
```

### Context Resolution
Use `resolveContextValue<T>(key, context, legIndex?)` to get values with proper priority:
```typescript
// Example: Get number of travelers
const travelers = resolveContextValue<number>('numTravelers', context, activeLeg) || 1;
```

### Multi-Leg Trips
Users may plan trips with multiple segments:
- "Fly into SFO, drive to Yosemite, then fly out of LAX"
- Each leg can have its own overrides (different airports, dates, etc.)
- Track `activeLeg` to know which segment is being discussed

---

## Tool System

### Tool Handler Pattern
All tool handlers receive full context:
```typescript
async function handleToolName(
  input: ToolInput,
  facade: TravelFacade,
  context: ChatContext,
  activeLeg?: number
): Promise<any>
```

### Tool Status Display
Every tool has a human-readable status message shown to users during execution:
- Defined in `src/api/chat/types.ts` → `TOOL_DISPLAY_NAMES`
- Status is shown in the chat UI while the tool is running
- Example: `'search_flights': 'Searching for available flights...'`

**When adding a new tool:**
1. Add the tool definition to `src/api/chat/toolDefinitions.ts`
2. Add the handler in `src/api/chat/index.ts`
3. Add the display name to `TOOL_DISPLAY_NAMES` in `src/api/chat/types.ts`
4. Add to `mobile/src/hooks/useToolSettings.ts` for toggle support

### Tool Toggle System
Users can enable/disable individual tools in the Tool Settings menu:
- Managed by `mobile/src/hooks/useToolSettings.ts`
- Tools are filtered by park mode (national/state)
- Enabled tools are passed to API via `context.toolSettings.enabledTools`
- API filters `toolDefinitions.ts` to only include enabled tools

**Tool categories:**
- `parks` - National/State park tools
- `travel` - Flights, cars, driving distance, EV charging
- `lodging` - Hotels
- `food` - Restaurants, reservations
- `activities` - Tours and experiences

**Park mode filtering:**
- Tools with `parkMode: 'national'` only appear in National Parks mode
- Tools with `parkMode: 'state'` only appear in State Parks mode
- Tools without `parkMode` appear in both modes

### Context-Aware Tool Behaviors

| Tool | Context Used |
|------|--------------|
| `search_flights` | `homeAirport` as default origin, `numTravelers` |
| `search_hotels` | `numTravelers` → calculate rooms needed |
| `search_restaurants` | `budget` → map to price level (frugal=1, moderate=2, luxury=4) |
| `search_ev_charging_stations` | Auto-detect Tesla owner from profile |
| `search_car_rentals` | EV preference from profile |
| `plan_park_trip` | `numTravelers` for all bookings |

### Tool Descriptions
Tool descriptions include valid park codes and examples to help Claude make accurate calls:
```typescript
description: `Get park hikes. Use official NPS park codes: ${ALL_PARK_CODES}`
```

---

## User Profile Parsing

### Profile Keywords to Detect
- **Budget**: "budget", "frugal", "luxury", "moderate"
- **EV/Tesla**: "tesla", "ev", "electric vehicle"
- **Family**: "family of X", "kids", "children", "toddlers"
- **Accessibility**: "wheelchair", "accessible", "mobility"
- **Pets**: "dog", "pet", "service animal"
- **Foodie**: "foodie", "culinary", "food lover"

### Profile vs Override Priority
```
User profile says "budget traveler" 
User asks "show me luxury hotels"
→ Honor the CURRENT REQUEST (luxury), not the profile
```

---

## Photo Gallery System

### Photo Sources
1. **NPS** - Official park images (highest confidence)
2. **Unsplash** - Supplementary scenic photos
3. **Yelp/Google** - Restaurant photos

### Photo Reference Structure
```typescript
interface PhotoReference {
  keyword: string;      // Search term that found this photo
  url: string;          // Image URL
  caption?: string;     // Display caption
  confidence?: number;  // Match confidence (0-1)
  source?: 'nps' | 'unsplash' | 'other';
}
```

### Restaurant Photos
- Added to gallery with `source: 'other'`
- Caption format: `"Restaurant Name • X.X miles to Park Name"`
- Both Yelp and Google Places results include photos

---

## Error Handling

### User-Friendly Error Messages
Errors should guide users to fix the issue, not just report it:

| Error Type | Message Style |
|------------|---------------|
| 500 | "Try being more specific - for example, 'Help me plan a 3-day trip to Yellowstone'" |
| Network | "Check your internet connection and tap retry when you're back online" |
| 4xx | "Try rephrasing - for example: 'What are the best hikes in Zion?'" |

### Error UI
- Use amber/gray styling, not alarming red
- Always provide a retry button
- Store `lastUserMessage` for retry functionality

---

## Mobile App Considerations

### React Native Limitations
- `fetch` doesn't support streaming (`response.body.getReader()`)
- Use regular API calls with simulated loading states instead of SSE
- Loading status updates: "Thinking..." → "Analyzing..." → "Searching..." → "Processing..."

### Text Formatting
The app displays plain text. Never use:
- Asterisks for bold/italics
- Hashtags for headers
- Underscores for dividers
- ALL CAPS for emphasis

Always use:
- Bullet points with "•" symbol
- Title Case for headers

**Never use emojis in code or UI text.** This is a strict rule for all code contributions.

---

## System Prompt Injection

### Context Info Building
The system prompt is enhanced with user context:
1. User location and nearest airport
2. Parks in user's state (auto-suggested)
3. Current trip details
4. User profile/preferences

### Park Reference in Prompt
```
NATIONAL PARKS REFERENCE (use exact names and codes):
Acadia National Park (acad), Arches National Park (arch), ...

Parks are located in these states: alaska, arizona, arkansas, california, ...
```

---

## File Structure Reference

```
src/
├── api/
│   └── chat/
│       ├── index.ts          # Main chat handler, tool dispatch
│       ├── types.ts          # ChatContext, TripLeg, resolveContextValue
│       ├── systemPrompt.ts   # System prompt with NPS data injection
│       ├── toolDefinitions.ts # Claude tool schemas with park codes
│       ├── parkFeatures.ts   # Park-specific photo keywords
│       └── responseProcessor.ts
├── utils/
│   └── parkCodeLookup.ts     # NPS park data, findParkCode()
├── providers/
│   ├── YelpAdapter.ts        # Restaurant search, reservations
│   ├── GoogleMapsAdapter.ts  # Driving distance, restaurant fallback
│   └── ...
mobile/
├── src/
│   ├── screens/
│   │   └── HomeScreen.tsx    # Main chat UI, error handling
│   ├── components/
│   │   └── home/
│   │       ├── OnboardingFlow.tsx  # NATIONAL_PARKS array
│   │       └── ChatMessages.tsx    # Error styling
│   └── services/
│       └── api.ts            # API calls, loading states
```

---

## Theme System (National vs State Parks)

The app has two modes with distinct color themes:

### National Parks Mode (Green Theme)
- **Primary**: `#22C55E` (green)
- **Primary Medium**: `#166534` (dark green)
- **Chip Background**: `rgba(34, 197, 94, 0.15)`
- **Chip Border**: `rgba(34, 197, 94, 0.3)`

### State Parks Mode (Brown Theme)
- **Primary**: `#CD853F` (peru/brown)
- **Primary Medium**: `#8B5A2B` (saddle brown)
- **Chip Background**: `rgba(139, 90, 43, 0.2)`
- **Chip Border**: `rgba(139, 90, 43, 0.3)`

### Using the Theme
```typescript
import { useParkTheme } from '../../hooks';

const { theme, isStateMode } = useParkTheme();

// Use theme colors dynamically
<View style={{ backgroundColor: theme.chipBackground, borderColor: theme.chipBorder }}>
<Text style={{ color: theme.primary }}>
```

### Theme-Aware Components
All new UI text and components should respect the current park mode theme:
- Use `theme.primary` for accent colors, not hardcoded green
- Use `theme.chipBackground` and `theme.chipBorder` for chips/badges
- Check `isStateMode` if you need conditional styling

---

## S3 Data Layer

### Architecture
**S3 is the authoritative data source** for all park and trail information. The data flow is:

```
External APIs (NPS, TrailAPI, Recreation.gov)
           ↓
   Data Scripts (fetch, merge, enrich)
           ↓
   S3 Bucket (tripagent-park-data)
           ↓
   S3ParkDataService (reads from S3)
           ↓
   App/Tool Handlers
```

### Key Principles
1. **Never hardcode data in scripts** - Scripts fetch from APIs and upload to S3
2. **S3 is the single source of truth** - All app code reads from S3, not local files
3. **Scripts are for data pipeline only** - Fetch → Transform → Upload to S3
4. **Curated data lives in S3** - Not in TypeScript configuration objects

### S3 Bucket Structure
```
s3://tripagent-park-data/
├── parks/
│   ├── index.json              # Park metadata index
│   └── {parkCode}/             # Per-park data
├── trails/
│   ├── api-trails.json         # NPS API trail data (63 national parks)
│   ├── all-parks-trails.json   # Curated trail data (migrated from AllTrails)
│   └── state-parks/
│       ├── WI/trails.json      # Wisconsin state parks
│       ├── FL/trails.json      # Florida state parks
│       └── {STATE}/trails.json # Future states
└── photos/
    └── {parkCode}/             # Park photos
```

### Data Scripts
| Script | Purpose |
|--------|---------|
| `fetchAndUploadTrails.ts` | Fetch NPS API trails, upload to S3 |
| `fetchStateTrails.ts` | Fetch state park trails from TrailAPI, upload to S3 |
| `migrateTrailsToGoogleMaps.ts` | One-time migration, adds Google Maps URLs |
| `generateCoverageReport.ts` | Generate coverage dashboard from S3 data |

### Adding New Data
1. Create a fetch script that calls external APIs
2. Transform data to match our schema
3. Upload to appropriate S3 path
4. Verify S3ParkDataService can read it

### Environment Variables
```
PARK_DATA_S3_BUCKET=tripagent-park-data
AWS_REGION=us-east-1
```

---

## Code Organization

### File Size Limits
**Maximum ~800 lines per file** to ensure code is modular and deterministic:
- Large files are harder to maintain and test
- Claude/AI tools work better with focused, single-purpose files
- Break up files that exceed this limit into logical modules

### Refactoring Patterns
When a file grows too large, extract into separate modules:

| Original | Extracted Modules |
|----------|-------------------|
| `src/api/chat/index.ts` | `toolHandlers/parks.ts`, `toolHandlers/travel.ts`, `toolHandlers/food.ts` |
| Large component files | Separate hooks, utils, and sub-components |
| Monolithic services | Domain-specific adapters |

### Module Structure
```
src/api/chat/
├── index.ts              # Main entry, routing only (~200 lines)
├── toolHandlers/
│   ├── parks.ts          # Park-related tool handlers
│   ├── travel.ts         # Flight, car, driving tools
│   ├── lodging.ts        # Hotel tools
│   ├── food.ts           # Restaurant tools
│   └── activities.ts     # Tour/experience tools
├── systemPrompt.ts
├── toolDefinitions.ts
└── types.ts
```

---

## Key Principles

1. **Authoritative Data**: Always use NPS API data for park information
2. **Override Priority**: User's current request > saved profile > defaults
3. **Context Everywhere**: Pass ChatContext to all tools that need it
4. **Graceful Errors**: Guide users to fix issues, don't just report them
5. **Mobile-First**: Consider React Native limitations in all implementations
6. **Leg Isolation**: Multi-segment trips can have per-leg overrides
7. **Theme Awareness**: All UI should use `useParkTheme()` for colors, not hardcoded values
8. **Modular Code**: Keep files under ~800 lines, extract logical modules when growing
