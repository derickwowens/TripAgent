# TripAgent - Copilot Instructions

> This document describes the architecture, rules, and context management for TripAgent, a National Park trip planning AI assistant.

## Overview

TripAgent is a React Native mobile app with an Express.js backend that uses Claude AI to help users plan National Park trips. The app integrates multiple APIs (NPS, Yelp, Google Maps, Unsplash, Amadeus) through a unified tool system.

---

## Data Architecture Philosophy

### S3 as an Aggregation Layer

The S3 bucket (`tripagent-park-data`) is the **aggregation layer** for data collected from multiple disparate sources. It is NOT a simple mirror of any single API.

**Key Principles:**

1. **Multi-Source Aggregation**: Data is collected from many sources (NPS API, state park websites, Recreation.gov, TrailAPI, AllTrails, state-specific GIS systems) and normalized into a unified schema.

2. **Schema Normalization**: All data conforms to `data/schema/park.schema.ts` regardless of source. This enables consistent querying and display.

3. **Delta Updates Only**: When syncing data, only update deltas or new data. Never overwrite existing curated/enriched information. States like WI have comprehensive manually-curated data that must be preserved.

4. **Complete Metadata**: Every record must include all metadata needed for system functionality:
   - Coordinates (lat/lng for mapping)
   - Links (official website, AllTrails, Google Maps, Recreation.gov)
   - Identifiers for cross-referencing

5. **Link Priority**: When multiple URLs exist, use in this order:
   - Official state/park website (PRIMARY - most authoritative)
   - AllTrails URL (SECONDARY - trail discovery)
   - Google Maps URL (FALLBACK - last resort for navigation)

6. **No Single Source Dependency**: There is rarely a single "source of truth" for all data about a park or trail. Our value is in aggregating and normalizing data from many places.

**S3 Structure:**
```
tripagent-park-data/
├── state-parks/{STATE}/index.json    # State park metadata
├── trails/state-parks/{STATE}/trails.json  # Trail data per state
├── national/{parkCode}/data.json     # National park data
└── trails/all-parks-trails.json      # Combined trail index
```

---

## Authoritative Data Sources

### National Park Service (NPS) API
- **Source**: `https://developer.nps.gov/api/v1/parks`
- **Usage**: All park names, codes, and state mappings come from NPS API
- **Files using NPS data**:
  - `src/utils/parkCodeLookup.ts` - Park code lookup and validation
  - `src/api/chat/parkFeatures.ts` - Park-specific photo features
  - `src/api/chat/systemPrompt.ts` - System prompt park references
  - `src/api/chat/toolDefinitions.ts` - Tool descriptions with park codes
  - `mobile/src/components/home/OnboardingFlow.tsx` - Random park selection

### Park Code Format
- 4-letter lowercase codes (e.g., `yose`, `yell`, `grca`, `zion`)
- Always use official NPS codes for API calls
- Full list: `acad, arch, badl, bibe, bisc, blca, brca, cany, care, cave, chis, cong, crla, cuva, deva, dena, drto, ever, gaar, jeff, glac, glba, grca, grte, grba, grsa, grsm, gumo, hale, havo, hosp, indu, isro, jotr, katm, kefj, kova, lacl, lavo, maca, meve, mora, neri, noca, olym, pefo, pinn, redw, romo, sagu, seki, shen, thro, viis, voya, whsa, wica, wrst, yell, yose, zion`

---

## Context Management System

### Context Priority (highest to lowest)
1. **Leg-specific override** - Override for a specific trip segment
2. **Conversation override** - User changed something in current chat
3. **Trip context** - Current trip being planned
4. **Profile defaults** - User's saved preferences
5. **System defaults** - Fallback values

### ChatContext Structure
```typescript
interface ChatContext {
  userLocation?: {
    city: string;
    state: string;
    nearestAirport: string;  // Auto-detected, used as flight origin default
  };
  tripContext?: {
    destination?: string;
    parkCode?: string;
    numDays?: number;
    numTravelers?: number;
    overrides?: Record<string, any>;  // Dynamic overrides from chat
    legs?: TripLeg[];                  // Multi-segment trips
    activeLeg?: number;                // Currently discussed leg
  };
  userProfile?: string;    // Raw profile text
  defaults?: ContextDefaults;  // Parsed preferences
}
```

### Context Resolution
Use `resolveContextValue<T>(key, context, legIndex?)` to get values with proper priority:
```typescript
// Example: Get number of travelers
const travelers = resolveContextValue<number>('numTravelers', context, activeLeg) || 1;
```

### Multi-Leg Trips
Users may plan trips with multiple segments:
- "Fly into SFO, drive to Yosemite, then fly out of LAX"
- Each leg can have its own overrides (different airports, dates, etc.)
- Track `activeLeg` to know which segment is being discussed

---

## Tool System

### Tool Handler Pattern
All tool handlers receive full context:
```typescript
async function handleToolName(
  input: ToolInput,
  facade: TravelFacade,
  context: ChatContext,
  activeLeg?: number
): Promise<any>
```

### Tool Status Display
Every tool has a human-readable status message shown to users during execution:
- Defined in `src/api/chat/types.ts` → `TOOL_DISPLAY_NAMES`
- Status is shown in the chat UI while the tool is running
- Example: `'search_flights': 'Searching for available flights...'`

**When adding a new tool:**
1. Add the tool definition to `src/api/chat/toolDefinitions.ts`
2. Add the handler in `src/api/chat/index.ts`
3. Add the display name to `TOOL_DISPLAY_NAMES` in `src/api/chat/types.ts`
4. Add to `mobile/src/hooks/useToolSettings.ts` for toggle support

### Tool Toggle System
Users can enable/disable individual tools in the Tool Settings menu:
- Managed by `mobile/src/hooks/useToolSettings.ts`
- Tools are filtered by park mode (national/state)
- Enabled tools are passed to API via `context.toolSettings.enabledTools`
- API filters `toolDefinitions.ts` to only include enabled tools

**Tool categories:**
- `parks` - National/State park tools
- `travel` - Flights, cars, driving distance, EV charging
- `lodging` - Hotels
- `food` - Restaurants, reservations
- `activities` - Tours and experiences

**Park mode filtering:**
- Tools with `parkMode: 'national'` only appear in National Parks mode
- Tools with `parkMode: 'state'` only appear in State Parks mode
- Tools without `parkMode` appear in both modes

### Context-Aware Tool Behaviors

| Tool | Context Used |
|------|--------------|
| `search_flights` | `homeAirport` as default origin, `numTravelers` |
| `search_hotels` | `numTravelers` → calculate rooms needed |
| `search_restaurants` | `budget` → map to price level (frugal=1, moderate=2, luxury=4) |
| `search_ev_charging_stations` | Auto-detect Tesla owner from profile |
| `search_car_rentals` | EV preference from profile |
| `plan_park_trip` | `numTravelers` for all bookings |

### Tool Descriptions
Tool descriptions include valid park codes and examples to help Claude make accurate calls:
```typescript
description: `Get park hikes. Use official NPS park codes: ${ALL_PARK_CODES}`
```

---

## User Profile Parsing

### Profile Keywords to Detect
- **Budget**: "budget", "frugal", "luxury", "moderate"
- **EV/Tesla**: "tesla", "ev", "electric vehicle"
- **Family**: "family of X", "kids", "children", "toddlers"
- **Accessibility**: "wheelchair", "accessible", "mobility"
- **Pets**: "dog", "pet", "service animal"
- **Foodie**: "foodie", "culinary", "food lover"

### Profile vs Override Priority
```
User profile says "budget traveler" 
User asks "show me luxury hotels"
→ Honor the CURRENT REQUEST (luxury), not the profile
```

---

## Photo Gallery System

### Photo Sources
1. **NPS** - Official park images (highest confidence)
2. **Unsplash** - Supplementary scenic photos
3. **Yelp/Google** - Restaurant photos

### Photo Reference Structure
```typescript
interface PhotoReference {
  keyword: string;      // Search term that found this photo
  url: string;          // Image URL
  caption?: string;     // Display caption
  confidence?: number;  // Match confidence (0-1)
  source?: 'nps' | 'unsplash' | 'other';
}
```

### Restaurant Photos
- Added to gallery with `source: 'other'`
- Caption format: `"Restaurant Name • X.X miles to Park Name"`
- Both Yelp and Google Places results include photos

---

## Error Handling

### User-Friendly Error Messages
Errors should guide users to fix the issue, not just report it:

| Error Type | Message Style |
|------------|---------------|
| 500 | "Try being more specific - for example, 'Help me plan a 3-day trip to Yellowstone'" |
| Network | "Check your internet connection and tap retry when you're back online" |
| 4xx | "Try rephrasing - for example: 'What are the best hikes in Zion?'" |

### Error UI
- Use amber/gray styling, not alarming red
- Always provide a retry button
- Store `lastUserMessage` for retry functionality

---

## Mobile App Considerations

### React Native Limitations
- `fetch` doesn't support streaming (`response.body.getReader()`)
- Use regular API calls with simulated loading states instead of SSE
- Loading status updates: "Thinking..." → "Analyzing..." → "Searching..." → "Processing..."

### Text Formatting
The app displays plain text. Never use:
- Asterisks for bold/italics
- Hashtags for headers
- Underscores for dividers
- ALL CAPS for emphasis

Always use:
- Bullet points with "•" symbol
- Title Case for headers

**Never use emojis in code or UI text.** This is a strict rule for all code contributions.

---

## System Prompt Injection

### Context Info Building
The system prompt is enhanced with user context:
1. User location and nearest airport
2. Parks in user's state (auto-suggested)
3. Current trip details
4. User profile/preferences

### Park Reference in Prompt
```
NATIONAL PARKS REFERENCE (use exact names and codes):
Acadia National Park (acad), Arches National Park (arch), ...

Parks are located in these states: alaska, arizona, arkansas, california, ...
```

---

## File Structure Reference

```
src/
├── api/
│   └── chat/
│       ├── index.ts          # Main chat handler, tool dispatch
│       ├── types.ts          # ChatContext, TripLeg, resolveContextValue
│       ├── systemPrompt.ts   # System prompt with NPS data injection
│       ├── toolDefinitions.ts # Claude tool schemas with park codes
│       ├── parkFeatures.ts   # Park-specific photo keywords
│       └── responseProcessor.ts
├── utils/
│   └── parkCodeLookup.ts     # NPS park data, findParkCode()
├── providers/
│   ├── YelpAdapter.ts        # Restaurant search, reservations
│   ├── GoogleMapsAdapter.ts  # Driving distance, restaurant fallback
│   └── ...
mobile/
├── src/
│   ├── screens/
│   │   └── HomeScreen.tsx    # Main chat UI, error handling
│   ├── components/
│   │   └── home/
│   │       ├── OnboardingFlow.tsx  # NATIONAL_PARKS array
│   │       └── ChatMessages.tsx    # Error styling
│   └── services/
│       └── api.ts            # API calls, loading states
```

---

## Theme System (National vs State Parks)

The app has two modes with distinct color themes:

### National Parks Mode (Green Theme)
- **Primary**: `#22C55E` (green)
- **Primary Medium**: `#166534` (dark green)
- **Chip Background**: `rgba(34, 197, 94, 0.15)`
- **Chip Border**: `rgba(34, 197, 94, 0.3)`

### State Parks Mode (Brown Theme)
- **Primary**: `#CD853F` (peru/brown)
- **Primary Medium**: `#8B5A2B` (saddle brown)
- **Chip Background**: `rgba(139, 90, 43, 0.2)`
- **Chip Border**: `rgba(139, 90, 43, 0.3)`

### Using the Theme
```typescript
import { useParkTheme } from '../../hooks';

const { theme, isStateMode } = useParkTheme();

// Use theme colors dynamically
<View style={{ backgroundColor: theme.chipBackground, borderColor: theme.chipBorder }}>
<Text style={{ color: theme.primary }}>
```

### Theme-Aware Components
All new UI text and components should respect the current park mode theme:
- Use `theme.primary` for accent colors, not hardcoded green
- Use `theme.chipBackground` and `theme.chipBorder` for chips/badges
- Check `isStateMode` if you need conditional styling

---

## S3 Data Layer

### Architecture
**S3 is the authoritative data source** for all park and trail information. The data flow is:

```
External APIs (NPS, TrailAPI, Recreation.gov)
           ↓
   Data Scripts (fetch, merge, enrich)
           ↓
   S3 Bucket (tripagent-park-data)
           ↓
   S3ParkDataService (reads from S3)
           ↓
   App/Tool Handlers
```

### Key Principles
1. **Never hardcode data in scripts** - Scripts fetch from APIs and upload to S3
2. **S3 is the single source of truth** - All app code reads from S3, not local files
3. **Scripts are for data pipeline only** - Fetch → Transform → Upload to S3
4. **Curated data lives in S3** - Not in TypeScript configuration objects

### S3 Bucket Structure
```
s3://tripagent-park-data/
├── parks/
│   ├── index.json              # Park metadata index
│   └── {parkCode}/             # Per-park data
├── trails/
│   ├── api-trails.json         # NPS API trail data (63 national parks)
│   ├── all-parks-trails.json   # Curated trail data (migrated from AllTrails)
│   └── state-parks/
│       ├── WI/trails.json      # Wisconsin state parks
│       ├── FL/trails.json      # Florida state parks
│       └── {STATE}/trails.json # Future states
└── photos/
    └── {parkCode}/             # Park photos
```

### Data Scripts
| Script | Purpose |
|--------|---------|
| `fetchAndUploadTrails.ts` | Fetch NPS API trails, upload to S3 |
| `fetchStateTrails.ts` | Fetch state park trails from TrailAPI, upload to S3 |
| `migrateTrailsToGoogleMaps.ts` | One-time migration, adds Google Maps URLs |
| `generateCoverageReport.ts` | Generate coverage dashboard from S3 data |

### Adding New Data
1. Create a fetch script that calls external APIs
2. Transform data to match our schema
3. Upload to appropriate S3 path
4. Verify S3ParkDataService can read it

### Environment Variables
```
PARK_DATA_S3_BUCKET=tripagent-park-data
AWS_REGION=us-east-1
```

---

## Code Organization

### File Size Limits
**Maximum ~800 lines per file** to ensure code is modular and deterministic:
- Large files are harder to maintain and test
- Claude/AI tools work better with focused, single-purpose files
- Break up files that exceed this limit into logical modules

### Refactoring Patterns
When a file grows too large, extract into separate modules:

| Original | Extracted Modules |
|----------|-------------------|
| `src/api/chat/index.ts` | `toolHandlers/parks.ts`, `toolHandlers/travel.ts`, `toolHandlers/food.ts` |
| Large component files | Separate hooks, utils, and sub-components |
| Monolithic services | Domain-specific adapters |

### Module Structure
```
src/api/chat/
├── index.ts              # Main entry, routing only (~200 lines)
├── toolHandlers/
│   ├── parks.ts          # Park-related tool handlers
│   ├── travel.ts         # Flight, car, driving tools
│   ├── lodging.ts        # Hotel tools
│   ├── food.ts           # Restaurant tools
│   └── activities.ts     # Tour/experience tools
├── systemPrompt.ts
├── toolDefinitions.ts
└── types.ts
```

---

## Deployment

### Always Use Deploy Scripts

**Never manually increment versions or run eas build directly.** Always use the deployment scripts:

```bash
# iOS deployment
./scripts/deploy-ios.sh [major|minor|hotfix] [options]

# Android deployment  
./scripts/deploy-android.sh [major|minor|hotfix] [options]

# Deploy both platforms
./scripts/deploy-all.sh [major|minor|hotfix] [options]
```

### Version Bump Types

| Type | Example | When to Use |
|------|---------|-------------|
| `major` | 2.0.0 → 3.0.0 | Breaking changes, major new features |
| `minor` | 2.3.0 → 2.4.0 | New features, significant improvements |
| `hotfix` | 2.3.7 → 2.3.8 | Bug fixes, small patches |

### Script Options

```bash
--rc               # Build as Release Candidate for closed testing
--validate-links   # Run NPS link validation before build
-i, --increment    # Increment version and build number
-b, --build-only   # Increment build number only (keep version)
-y, --yes          # Auto-confirm all prompts (non-interactive)
--apple-id=EMAIL   # Apple ID for App Store Connect
```

### Examples

```bash
# Minor version release to iOS
./scripts/deploy-ios.sh minor

# Hotfix to both platforms
./scripts/deploy-all.sh hotfix

# Release candidate for testing
./scripts/deploy-ios.sh minor --rc
```

The scripts handle:
- Version/build number incrementing in app.json
- Git commit with version tag
- EAS build submission
- App Store / Play Store upload

---

## Adventure Map (Trail Map Overlay)

### Architecture
The Adventure Map is a slide-out map panel that shows trails, parks, and campgrounds when a destination is detected in conversation. It uses a multi-layer caching system for performance.

### Map Data Caching
**Module-level cache** in `mobile/src/hooks/useTrailMap.ts` — persists across re-renders and conversation switches:

```
preloadMapData(stateCode)  →  mapDataCache (Map<string, {trails, parks, campgrounds}>)
                                    ↑
fetchTrails() checks cache first, stores results after fresh fetch
```

**Cache is populated at 3 points:**
1. **App startup** — `preloadMapData(userLocation.state)` in HomeScreen
2. **Destination detected** — `preloadMapData(sc)` called in every `initFromConversation` detection path
3. **Manual fetch** — `fetchTrails()` stores results in cache after API call

**Deduplication:** `pendingFetches` map prevents concurrent fetches for the same state code.

### Key Files
| File | Purpose |
|------|---------|
| `mobile/src/hooks/useTrailMap.ts` | Hook + module-level cache + `preloadMapData()` |
| `mobile/src/components/home/TrailMapPanel.tsx` | Map UI, markers, viewport filtering |
| `mobile/src/services/api.ts` | `fetchTrailsForMap`, `fetchTrailGeometry`, `fetchParksForMap`, `fetchCampgroundsForMap` |
| `src/providers/parks/S3ParkDataService.ts` | `getTrailsForMap(state, parkId?, includeGeometry?)` |

### Android-Specific Considerations
- **Custom View markers** require `tracksViewChanges` for bitmap capture on Android
- Use `androidMarkersReady` state: start `true` (capture bitmap), switch to `false` after 500ms (enable touch)
- **Viewport-only rendering**: Only render `visibleTrails` (filtered by map region) to prevent performance issues with 2000+ markers
- Map is **locked during loading** (`scrollEnabled={!loading}`, `zoomEnabled={!loading}`)

### Geometry Lazy Loading
Trail geometry (polyline coordinates) is large (~29MB for some states). It is excluded from initial map responses and fetched lazily:
- Server: `includeGeometry` query param on `/api/trails/map/:stateCode` (default `false`)
- Client: `fetchTrailGeometry()` called only when user toggles "Trail Lines" checkbox
- Checkbox only appears when trail data is cached and loaded (`hasTrailsLoaded && canShowTrailLines`)

---

## Local Development Scripts

### Parallel Testing (iOS + Android)
Scripts use dedicated ports so both platforms can run simultaneously:

| | Android (`restart-android.sh`) | iOS (`restart-ios.sh`) |
|---|---|---|
| **API port** | 3001 | 3002 |
| **Metro port** | 8081 | 8082 |
| **PID file** | `/tmp/tripagent-android.pids` | `/tmp/tripagent-ios.pids` |
| **API log** | `/tmp/tripagent-android-api.log` | `/tmp/tripagent-ios-api.log` |
| **Expo log** | `/tmp/tripagent-android-expo.log` | `/tmp/tripagent-ios-expo.log` |

- Each script only kills its own processes via PID files + port-specific cleanup
- `EXPO_PUBLIC_API_URL` is overridden inline to point to the correct API port
- Scripts never use global `pkill` that could kill the other platform's processes

---

## Key Principles

1. **Authoritative Data**: Always use NPS API data for park information
2. **Override Priority**: User's current request > saved profile > defaults
3. **Context Everywhere**: Pass ChatContext to all tools that need it
4. **Graceful Errors**: Guide users to fix issues, don't just report them
5. **Mobile-First**: Consider React Native limitations in all implementations
6. **Leg Isolation**: Multi-segment trips can have per-leg overrides
7. **Theme Awareness**: All UI should use `useParkTheme()` for colors, not hardcoded values
8. **Modular Code**: Keep files under ~800 lines, extract logical modules when growing
9. **Use Deploy Scripts**: Always use `./scripts/deploy-ios.sh` or `deploy-android.sh` for releases
10. **Map Data Caching**: Pre-load map data on destination detection; never re-fetch cached state data
